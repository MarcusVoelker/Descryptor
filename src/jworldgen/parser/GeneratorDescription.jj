/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(RuleParser)package jworldgen.parser;

import java.io.StringReader;
import jworldgen.parser.parseStructure.*;
import jworldgen.exceptionHandler.ExceptionLogger;
import jworldgen.exceptionHandler.LoggerLevel;
import jworldgen.exceptionHandler.CriticalFailure;

public class RuleParser{  public static ParseList parse(String ruleCode) throws CriticalFailure  {
    StringReader reader = new StringReader(ruleCode);    RuleParser parser = new RuleParser(reader);
        ExceptionLogger.log("Reading input...", LoggerLevel.COARSE);    try    {      ParseList list = RuleParser.parseRoot();
      ExceptionLogger.log("No syntactic errors detected", LoggerLevel.COARSE);
      return list;    }    catch (Exception e)    {      ExceptionLogger.logException(e,LoggerLevel.CRITICAL);
      return null;    }    catch (Error e)    {      ExceptionLogger.logException(e,LoggerLevel.CRITICAL);
      return null;    }  }}PARSER_END(RuleParser)SKIP :{  " "| "\r"| "\t"| "\n"
| "/*": IN_COMMENT}

< IN_COMMENT > SKIP:{
  < ~[] >}
< IN_COMMENT > SKIP :
{
  "*/": DEFAULT
}
TOKEN : /* Partitions */{  < ROOM : "Room" >| < AREA : "Area" >| < SUBAREA : "SubArea" >
| < STAMP : "Stamp" >
| < MODIFIER : "Modifier" >}

TOKEN : /* Room Keys */
{
  < WBLOCK : "WallBlock" >
| < FBLOCK : "FloorBlock" >
| < CBLOCK : "CeilingBlock" >
| < BG : "Background" >
}

TOKEN : /* Modifier and Area Keys */
{
  < PROB : "Prob" >
| < TYPE : "Type" >
}

TOKEN : /* SubArea Keys */
{
  < ATYPE : "AreaType" >
| < RTYPE : "RoomType" >
| < XPOS : "xPos" >
| < YPOS : "yPos" >
| < WIDTH : "width" >
| < HEIGHT : "height" >
| < COUNT : "count" >
}
TOKEN : /* Misc Identifiers */{  < CONSTANT : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >
| < IDENT : ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
| < FLOAT : < CONSTANT > "." < CONSTANT > >}

ParseList parseRoot():
{ParseList list = new ParseList();}
{	partition(list)
	{
	  return list;	}
}void partition(ParseList list) :{ParseRoom room; ParseArea area; ParseModifier modifier;}{  room = room() partition(list)
  {
    list.addRoom(room);
  }
  
| area = area() partition(list)
  {
    list.addArea(area);
  }
| modifier = modifier() partition(list)
  {
    list.addModifier(modifier);
  }
| < EOF >}

void roomLine(ParseRoom room) :
{Token block;}
{
  < WBLOCK > "=" block = < IDENT >
  {
    room.setWalls(block.image);  }
| < FBLOCK > "=" block = < IDENT >
  {
    room.setFloor(block.image);
  }
| < CBLOCK > "=" block = < IDENT >
  {
    room.setCeiling(block.image);
  }
| < BG > "=" block = < IDENT >
  {
    room.setBackground(block.image);
  }
}

void areaLine(ParseArea area) :
{Token probType; Token modType;}
{
  < TYPE > "=" probType = < IDENT >
  {
    area.setType(probType.image);
  }
| < MODIFIER > modType = < IDENT >
  {	area.addModifier(modType.image);
  }  
}

void modifierLine(ParseModifier modifier) :
{Token probType; Token id;}
{
  < TYPE > id = < CONSTANT > "=" probType = < IDENT >
  {
    modifier.addType(probType.image, Integer.parseInt(id.image));
  }
| < PROB > id = < CONSTANT > "=" probType = < CONSTANT >
  {
    modifier.addProb(Integer.parseInt(probType.image), Integer.parseInt(id.image));
  }
}

void subAreaLine(ParseSubArea subArea) :
{Token identifier; int[] ints; float[] floats;}
{
  < ATYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;  }
| < RTYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| < COUNT > "=" ints = combExp()
  {
    subArea.countLow = ints[0];
    subArea.countHigh = ints[1];
  }
| < XPOS > "=" floats = probExp()
  {
    subArea.xPosLow = floats[0];
    subArea.xPosHigh = floats[1];
  }
| < YPOS > "=" floats = probExp()
  {
    subArea.yPosLow = floats[0];
    subArea.yPosHigh = floats[1];
  }
| < WIDTH > "=" floats = probExp()
  {
    subArea.widthLow = floats[0];
    subArea.widthHigh = floats[1];
  }
| < HEIGHT > "=" floats = probExp()
  {
    subArea.heightLow = floats[0];
    subArea.heightHigh = floats[1];
  }
}

void stampLine(ParseSubArea subArea) :
{Token identifier; int[] ints; float[] floats;}
{
  < ATYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| < RTYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| < COUNT > "=" ints = combExp()
  {
    subArea.countLow = ints[0];
    subArea.countHigh = ints[1];
  }
| < XPOS > "=" floats = probExp()
  {
    subArea.xPosLow = floats[0];
    subArea.xPosHigh = floats[1];
  }
| < YPOS > "=" floats = probExp()
  {
    subArea.yPosLow = floats[0];
    subArea.yPosHigh = floats[1];
  }
| < WIDTH > "=" ints = combExp()
  {
    subArea.widthLow = ints[0];
    subArea.widthHigh = ints[1];
  }
| < HEIGHT > "=" ints = combExp()
  {
    subArea.heightLow = ints[0];
    subArea.heightHigh = ints[1];
  }
}

ParseRoom room() :
{ParseRoom room = new ParseRoom(); Token ident;}
{
  < ROOM > ident = < IDENT > "{" (roomLine(room))* "}"
  {
    room.setIdentifier(ident.image);	return room;
  }
}

void subArea(ParseArea area):
{ParseSubArea subArea = new ParseSubArea(); subArea.isStamp = false;}
{
  < SUBAREA > "{" (subAreaLine(subArea))* "}"
  {	area.addSubArea(subArea);
  }}

void stamp(ParseArea area):
{ParseSubArea subArea = new ParseSubArea(); subArea.isStamp = true;}
{
  < STAMP > "{" (stampLine(subArea))* "}"
  {
	area.addSubArea(subArea);
  }
}


ParseArea area():
{ParseArea area = new ParseArea(); Token ident;}
{  < AREA > ident = < IDENT > "{" (areaLine(area) | subArea(area) | stamp(area))* "}"
  {
    area.setIdentifier(ident.image);	return area;
  }
}

ParseModifier modifier():
{ParseModifier modifier = new ParseModifier(); Token ident;}
{
  < MODIFIER > ident = < IDENT > "{" (modifierLine(modifier))* "}"
  {
    modifier.setIdentifier(ident.image);
	return modifier;
  }
}

int[] combExp():
{int leftVal; int rightVal;}
{	leftVal = intValExp() ":" rightVal = intValExp()
	{
	  return new int[]{leftVal,rightVal};	}
}

int intValExp():
{Token t;}{	t = < CONSTANT >
	{		return Integer.parseInt(t.image);
	}
|   t = "$n"
	{		return -1;
	}
|   t = "$i"
	{
		return -2;
	}
}

float floatValExp():
{Token t;}
{
	t = < FLOAT >
	{
		return Float.parseFloat(t.image);
	}
|   t = "$n"
	{
		return -1;
	}
|   t = "$i"
	{
		return -2;
	}
}

float[] probExp():
{float leftVal; float rightVal;}
{
	leftVal = floatValExp() ":" rightVal = floatValExp()
	{		return new float[]{leftVal,rightVal};
	}	  
}

int prob():
{Token id;}
{	< PROB > id = < CONSTANT >
	{		return Integer.parseInt(id.image);
	}	
}

int type():
{Token id;}{
  < TYPE > id = < CONSTANT >
	{
		return Integer.parseInt(id.image);
	}}  