/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(RuleParser)package jworldgen.parser;

import java.io.StringReader;
import java.util.Stack;
import java.util.LinkedList;
import jworldgen.parser.parseStructure.*;
import jworldgen.exceptionHandler.ExceptionLogger;
import jworldgen.exceptionHandler.LoggerLevel;
import jworldgen.exceptionHandler.CriticalFailure;

public class RuleParser{  public static ParseList parse(String ruleCode) throws CriticalFailure  {
    StringReader reader = new StringReader(ruleCode);    RuleParser parser = new RuleParser(reader);
        ExceptionLogger.log("Reading input...", LoggerLevel.COARSE);    try    {      ParseList list = RuleParser.parseRoot();
      ExceptionLogger.log("No syntactic errors detected", LoggerLevel.COARSE);
      return list;    }    catch (Exception e)    {      ExceptionLogger.logException(e,LoggerLevel.CRITICAL);
      return null;    }    catch (Error e)    {      ExceptionLogger.logException(e,LoggerLevel.CRITICAL);
      return null;    }  }}PARSER_END(RuleParser)SKIP :{  " "| "\r"| "\t"| "\n"
| "/*": IN_COMMENT}

< IN_COMMENT > SKIP:{
  < ~[] >}
< IN_COMMENT > SKIP :
{
  "*/": DEFAULT
}
TOKEN : /* Partitions */{  < AREA : "Area" >| < SUBAREA : "SubArea" >
| < STAMP : "Stamp" >
| < MODIFIER : "Modifier" >}

TOKEN : /* Room Keys */
{
  < WBLOCK : "WallBlock" >
| < FBLOCK : "FloorBlock" >
| < CBLOCK : "CeilingBlock" >
| < BG : "Background" >
}

TOKEN : /* Modifier and Area Keys */
{
  < PROB : "Prob" >
| < TYPE : "Type" >
}

TOKEN : /* SubArea Keys */
{
  < ATYPE : "AreaType" >
| < RTYPE : "RoomType" >
}

TOKEN: /* ALE Operators */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < RANDOM : ":" >}

TOKEN: /* ALE Functions */
{  < SIN: "sin" >
| < COS: "cos" >
| < TAN: "tan" >
}TOKEN : /* Misc Identifiers */{  < INTEGER : (< MINUS >)? (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >
| < IDENT : ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
| < FLOAT : < INTEGER > "." < INTEGER > >
| < EOL : ";" >}

ParseList parseRoot():
{ParseList list = new ParseList();}
{	partition(list)
	{
	  return list;	}
}
void partition(ParseList list) :{ParseArea area; ParseModifier modifier;}{  area = area() partition(list)
  {
    list.addArea(area);
  }
| modifier = modifier() partition(list)
  {
    list.addModifier(modifier);
  }
| < EOF >}

void areaLine(ParseArea area) :
{Token probType; Token modType;}
{
  < TYPE > "=" probType = < IDENT >
  {
    area.setType(probType.image);
  }
| < MODIFIER > modType = < IDENT >
  {	area.addModifier(modType.image);
  }  
}

void modifierLine(ParseModifier modifier) :
{Token probType; Token id; ParseAssignment assignment;}
{
  < TYPE > id = < INTEGER > "=" probType = < IDENT >
  {
    modifier.addType(probType.image, Integer.parseInt(id.image));
  }
| < PROB > id = < INTEGER > "=" probType = < INTEGER >
  {
    modifier.addProb(Integer.parseInt(probType.image), Integer.parseInt(id.image));
  }
| assignment = assignment()
  {
    modifier.assignments.add(assignment);
  }
}

void subAreaLine(ParseSubArea subArea) :
{Token identifier; int[] ints; float[] floats; ParseAssignment assignment;}
{
  < ATYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;  }
| < RTYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| assignment = assignment()
  {
    subArea.assignments.add(assignment);
  }
}

void stampLine(ParseSubArea subArea) :
{Token identifier; int[] ints; float[] floats; ParseAssignment assignment;}
{
  < ATYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| < RTYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| assignment = assignment()
  {
    subArea.assignments.add(assignment);
  }
}

void subArea(ParseArea area):
{ParseSubArea subArea = new ParseSubArea(); subArea.isStamp = false;}
{
  < SUBAREA > "{" (subAreaLine(subArea))* "}"
  {	area.addSubArea(subArea);
  }}

void stamp(ParseArea area):
{ParseSubArea subArea = new ParseSubArea(); subArea.isStamp = true;}
{
  < STAMP > "{" (stampLine(subArea))* "}"
  {
	area.addSubArea(subArea);
  }
}


ParseArea area():
{ParseArea area = new ParseArea(); Token ident;}
{  < AREA > ident = < IDENT > "{" (areaLine(area) | subArea(area) | stamp(area))* "}"
  {
    area.setIdentifier(ident.image);	return area;
  }
}

ParseModifier modifier():
{ParseModifier modifier = new ParseModifier(); Token ident;}
{
  < MODIFIER > ident = < IDENT > "{" (modifierLine(modifier))* "}"
  {
    modifier.setIdentifier(ident.image);
	return modifier;
  }
}

int[] combExp():
{int leftVal; int rightVal;}
{	leftVal = intValExp() ":" rightVal = intValExp()
	{
	  return new int[]{leftVal,rightVal};	}
}

int intValExp():
{Token t;}{	t = < INTEGER >
	{		return Integer.parseInt(t.image);
	}
|   t = "$n"
	{		return -1;
	}
|   t = "$i"
	{
		return -2;
	}
}

float floatValExp():
{Token t;}
{
	t = < FLOAT >
	{
		return Float.parseFloat(t.image);
	}
|   t = "$n"
	{
		return -1;
	}
|   t = "$i"
	{
		return -2;
	}
}

float[] probExp():
{float leftVal; float rightVal;}
{
	leftVal = floatValExp() ":" rightVal = floatValExp()
	{		return new float[]{leftVal,rightVal};
	}	  
}

int prob():
{Token id;}
{	< PROB > id = < INTEGER >
	{		return Integer.parseInt(id.image);
	}	
}

int type():
{Token id;}{
  < TYPE > id = < INTEGER >
	{
		return Integer.parseInt(id.image);
	}}

ParseAssignment assignment():
{Token t; ParseALE ale;}
{
  t = < IDENT > "=" ale = ale()
  {
    return new ParseAssignment(t.image,ale);
  }}
ParseALE ale():
{LinkedList<ALEQueueElement> output = new LinkedList(); Stack opStack = new Stack();}
{
  aleShunt(output,opStack)
  {
    while (!opStack.empty())
    {		output.add((ALEQueueElement) opStack.pop());
    }    return new ParseALE(output);
  }}

void aleShunt(LinkedList<ALEQueueElement>  output, Stack opStack):
{}
{
 	(aleBracket(output,opStack)| aleOperator(output,opStack) | aleFunction(opStack) | aleLeaf(output))* < EOL > }

void aleBracket(LinkedList<ALEQueueElement>  output, Stack opStack):
{Token t;}
{
	t = "("
	{
		opStack.push(t.image);
	}
|   t = ")"
	{
		while (!opStack.peek().equals("("))
		{
			output.add((ALEQueueElement) opStack.pop());
		}
		opStack.pop();
	}
|   t = ","
	{
	  	while (!opStack.peek().equals("("))
		{
			output.add((ALEQueueElement) opStack.pop());
		}
	}
}

void aleOperator(LinkedList<ALEQueueElement> output, Stack opStack):
{Token t; ALEElementType type;}
{	(
	  t = < PLUS > { type = ALEElementType.PLUS; }
	|
	  t = < MINUS > { type = ALEElementType.MINUS; }
	)
	{		while (!opStack.empty())
		{
		  output.add((ALEQueueElement) opStack.pop());		}
		opStack.push(new ALEQueueElement(t.image,type));
	}

|   (
	  t = < MULTIPLY > { type = ALEElementType.MULTIPLY; }
	|
	  t = < DIVIDE > { type = ALEElementType.DIVIDE; }
	)
	{		while (!opStack.empty() && ((ALEQueueElement) opStack.peek()).type != ALEElementType.PLUS && ((ALEQueueElement) opStack.peek()).type != ALEElementType.MINUS)
		{			output.add((ALEQueueElement) opStack.pop());
		}
		opStack.push(new ALEQueueElement(t.image,type));
	}
|   t = < RANDOM >
	{
		while (!opStack.empty() && ((ALEQueueElement) opStack.peek()).type != ALEElementType.RANDOM)
		{
			output.add((ALEQueueElement) opStack.pop());
		}
		opStack.push(new ALEQueueElement(t.image,ALEElementType.RANDOM));
	}
}

void aleFunction(Stack opStack):
{Token t; ALEElementType type;}
{
	(
	  t = < SIN > { type = ALEElementType.SINE; }
	|
	  t = < COS > { type = ALEElementType.COSINE; }
	|
	  t = < TAN > { type = ALEElementType.TANGENT; }
	)
	{
		opStack.push(new ALEQueueElement(t.image,type));
	}
}

void aleLeaf(LinkedList<ALEQueueElement> output):
{Token t; ALEElementType type;}
{
  	(
  	  t = < FLOAT > { type = ALEElementType.FLOAT; }
  	|
  	  t = < IDENT > { type = ALEElementType.VARIABLE; }
  	|
  	  t = < INTEGER > { type = ALEElementType.INTEGER; }
  	)
  	{
  	  output.add(new ALEQueueElement(t.image,type));  	}
}
  