/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
}

PARSER_BEGIN(RuleParser)
package jworldgen.parser;

import java.io.StringReader;
import java.util.Stack;
import java.util.LinkedList;
import jworldgen.parser.parseStructure.*;
import jworldgen.exceptionHandler.ExceptionLogger;
import jworldgen.exceptionHandler.LoggerLevel;
import jworldgen.exceptionHandler.CriticalFailure;

public class RuleParser
{
  public static ParseList parse(String ruleCode) throws CriticalFailure
  {
    StringReader reader = new StringReader(ruleCode);
    RuleParser parser = new RuleParser(reader);
    
    ExceptionLogger.log("Reading input...", LoggerLevel.COARSE);
    try
    {
      ParseList list = RuleParser.parseRoot();
      ExceptionLogger.log("No syntactic errors detected", LoggerLevel.COARSE);
      return list;
    }
    catch (Exception e)
    {
      ExceptionLogger.logException(e,LoggerLevel.CRITICAL);
      return null;
    }
    catch (Error e)
    {
      ExceptionLogger.logException(e,LoggerLevel.CRITICAL);
      return null;
    }
  }
}

PARSER_END(RuleParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "/*": IN_COMMENT
}

< IN_COMMENT > SKIP:
{
  < ~[] >
}

< IN_COMMENT > SKIP :
{
  "*/": DEFAULT
}

TOKEN : /* Partitions */
{
  < AREA : "Area" >
| < SUBAREA : "SubArea" >
| < STAMP : "Stamp" >
| < MODIFIER : "Modifier" >
| < MODIFIERGROUP : "ModifierGroup" >
}

TOKEN : /* Room Keys */
{
  < WBLOCK : "WallBlock" >
| < FBLOCK : "FloorBlock" >
| < CBLOCK : "CeilingBlock" >
| < BG : "Background" >
}

TOKEN : /* Modifier and Area Keys */
{
  < PROB : "Prob" >
| < TYPE : "Type" >
| < MODTYPE : "ModType" >
| < CHANGETYPE : "ChangeType" >
}

TOKEN : /* SubArea Keys */
{
  < ATYPE : "AreaType" >
| < RTYPE : "RoomType" >
}

TOKEN: /* ALE Operators */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < RANDOM : ":" >
}

TOKEN: /* ALE Functions */
{
  < SIN: "sin" >
| < COS: "cos" >
| < TAN: "tan" >
| < ASIN: "asin" >
| < ACOS: "acos" >
| < ATAN: "atan" >
| < SQRT: "sqrt" >
}
TOKEN : /* Misc Identifiers */
{
  < SPECIAL : "$" >
| < INTEGER : (< MINUS >)? (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < IDENT : (< SPECIAL >)? ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
| < FLOAT : < INTEGER > "." < INTEGER > >
| < EOL : ";" >
}

ParseList parseRoot():
{ParseList list = new ParseList();}
{
	partition(list)
	{
	  return list;
	}
}

void partition(ParseList list) :
{ParseArea area; ParseModifier modifier; ParseModifierGroup mGroup;}
{
  area = area() partition(list)
  {
    list.addArea(area);
  }
| modifier = modifier() partition(list)
  {
    list.addModifier(modifier);
  }
| mGroup = modifierGroup() partition(list)
  {
    list.addModifierGroup(mGroup);
  }
| < EOF >
}

void areaLine(ParseArea area) :
{Token probType; Token modType;}
{
  < TYPE > "=" probType = < IDENT >
  {
    area.setType(probType.image);
  }
| < MODIFIERGROUP > modType = < IDENT >
  {
	area.addModifierGroup(modType.image);
  }  
}

void modifierLine(ParseModifier modifier) :
{Token probType; Token id; ParseAssignment assignment;}
{
  
  < MODTYPE > "=" probType = < IDENT >
  {
    modifier.setType(probType.image);
  }
| assignment = assignment()
  {
    modifier.assignments.add(assignment);
  }
}

void modifierGroupLine(ParseModifierGroup modifierGroup) :
{Token probType; Token id; ParseAssignment assignment;}
{
  
  < TYPE > 
  (
    id = < INTEGER > "=" probType = < IDENT >
    {
      modifierGroup.addType(probType.image, Integer.parseInt(id.image));
    }
  |
  	"=" probType = < IDENT >
  	{
      modifierGroup.addType(probType.image, 0);
    }
  )  
| < PROB > id = < INTEGER > "=" probType = < INTEGER >
  {
    modifierGroup.addProb(Integer.parseInt(probType.image), Integer.parseInt(id.image));
  }
| < CHANGETYPE > "=" probType = < IDENT >
  {
    modifierGroup.setChangeType(probType.image);
  }
| < MODIFIER > probType = < IDENT >
  {
    modifierGroup.addModifier(probType.image);
  }
| assignment = assignment()
  {
    modifierGroup.assignments.add(assignment);
  }
}

void subAreaLine(ParseSubArea subArea) :
{Token identifier; int[] ints; float[] floats; ParseAssignment assignment;}
{
  < ATYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| < RTYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| assignment = assignment()
  {
    subArea.assignments.add(assignment);
  }
}

void stampLine(ParseSubArea subArea) :
{Token identifier; int[] ints; float[] floats; ParseAssignment assignment;}
{
  < ATYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| < RTYPE > "=" identifier = < IDENT >
  {
    subArea.areaType = identifier.image;
  }
| assignment = assignment()
  {
    subArea.assignments.add(assignment);
  }
}

void subArea(ParseArea area):
{ParseSubArea subArea = new ParseSubArea(); subArea.isStamp = false;}
{
  < SUBAREA > "{" (subAreaLine(subArea))* "}"
  {
	area.addSubArea(subArea);
  }
}

void stamp(ParseArea area):
{ParseSubArea subArea = new ParseSubArea(); subArea.isStamp = true;}
{
  < STAMP > "{" (stampLine(subArea))* "}"
  {
	area.addSubArea(subArea);
  }
}


ParseArea area():
{ParseArea area = new ParseArea(); Token ident;}
{
  < AREA > ident = < IDENT > "{" (areaLine(area) | subArea(area) | stamp(area))* "}"
  {
    area.setIdentifier(ident.image);
	return area;
  }
}


ParseModifier modifier():
{ParseModifier modifier = new ParseModifier(); Token ident;}
{
  < MODIFIER > ident = < IDENT > "{" (modifierLine(modifier))* "}"
  {
    modifier.setIdentifier(ident.image);
	return modifier;
  }
}

ParseModifierGroup modifierGroup():
{ParseModifierGroup modifierGroup = new ParseModifierGroup(); Token ident;}
{
  < MODIFIERGROUP > ident = < IDENT > "{" (modifierGroupLine(modifierGroup))* "}"
  {
    modifierGroup.setIdentifier(ident.image);
    return modifierGroup;
  }
}

int prob():
{Token id;}
{
	< PROB > id = < INTEGER >
	{
		return Integer.parseInt(id.image);
	}	
}

int type():
{Token id;}
{
  < TYPE > id = < INTEGER >
	{
		return Integer.parseInt(id.image);
	}
}

ParseAssignment assignment():
{Token t; ParseALE ale;}
{
  t = < IDENT > "=" ale = ale()
  {
    return new ParseAssignment(t.image,ale);
  }
}
ParseALE ale():
{LinkedList<ALEQueueElement> output = new LinkedList(); Stack opStack = new Stack();}
{
  aleShunt(output,opStack)
  {
    while (!opStack.empty())
    {
		output.add((ALEQueueElement) opStack.pop());
    }
    return new ParseALE(output);
  }
}

void aleShunt(LinkedList<ALEQueueElement>  output, Stack opStack):
{}
{
 	(aleBracket(output,opStack)| aleOperator(output,opStack) | aleFunction(opStack) | aleLeaf(output))* < EOL > 
}

void aleBracket(LinkedList<ALEQueueElement>  output, Stack opStack):
{Token t;}
{
	t = "("
	{
		opStack.push(t.image);
	}
|   t = ")"
	{
		while (!opStack.peek().equals("("))
		{
			output.add((ALEQueueElement) opStack.pop());
		}
		opStack.pop();
	}
|   t = ","
	{
	  	while (!opStack.peek().equals("("))
		{
			output.add((ALEQueueElement) opStack.pop());
		}
	}
}

void aleOperator(LinkedList<ALEQueueElement> output, Stack opStack):
{Token t; ALEElementType type;}
{
	(
	  t = < PLUS > { type = ALEElementType.PLUS; }
	|
	  t = < MINUS > { type = ALEElementType.MINUS; }
	)
	{
		while (!opStack.empty() && !opStack.peek().equals("("))
		{
		  output.add((ALEQueueElement) opStack.pop());
		}
		opStack.push(new ALEQueueElement(t.image,type));
	}

|   (
	  t = < MULTIPLY > { type = ALEElementType.MULTIPLY; }
	|
	  t = < DIVIDE > { type = ALEElementType.DIVIDE; }
	)
	{
		while (!opStack.empty() && !opStack.peek().equals("(") &&((ALEQueueElement) opStack.peek()).type != ALEElementType.PLUS && ((ALEQueueElement) opStack.peek()).type != ALEElementType.MINUS)
		{
			output.add((ALEQueueElement) opStack.pop());
		}
		opStack.push(new ALEQueueElement(t.image,type));
	}
|   t = < RANDOM >
	{
		while (!opStack.empty() && ((ALEQueueElement) opStack.peek()).type != ALEElementType.RANDOM)
		{
			output.add((ALEQueueElement) opStack.pop());
		}
		opStack.push(new ALEQueueElement(t.image,ALEElementType.RANDOM));
	}
}

void aleFunction(Stack opStack):
{Token t; ALEElementType type;}
{
	(
	  t = < SIN > { type = ALEElementType.SINE; }
	|
	  t = < COS > { type = ALEElementType.COSINE; }
	|
	  t = < TAN > { type = ALEElementType.TANGENT; }
	|
	  t = < ASIN > { type = ALEElementType.ARCSINE; }
	|
	  t = < ACOS > { type = ALEElementType.ARCCOSINE; }
	|
	  t = < ATAN > { type = ALEElementType.ARCTANGENT; }
	|
	  t = < SQRT > { type = ALEElementType.SQRT; }
	)
	{
		opStack.push(new ALEQueueElement(t.image,type));
	}
}

void aleLeaf(LinkedList<ALEQueueElement> output):
{Token t; ALEElementType type;}
{
  	(
  	  t = < FLOAT > { type = ALEElementType.FLOAT; }
  	|
  	  t = < IDENT > { type = ALEElementType.VARIABLE; }
  	|
  	  t = < INTEGER > { type = ALEElementType.INTEGER; }
  	)
  	{
  	  output.add(new ALEQueueElement(t.image,type));
  	}
}

  